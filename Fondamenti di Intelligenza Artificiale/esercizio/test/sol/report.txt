========================================
REPORT ESERCITAZIONE MINI-LIBRERIA STATS
========================================

Studente: [Nome Studente]
Data: 19/12/2025

========================================
SEZIONE 1: PROMPT UTILIZZATI
========================================

-------------------------------------------
PROMPT A - Specifica Tecnica
-------------------------------------------

Genera una specifica tecnica in italiano per una mini-libreria C99 chiamata stats.
Deve includere: prototipi, pre/post-condizioni, codici errore, complessità e
note su overflow/precisione.
Funzioni: min, max, somma long long, media double, varianza popolazione double
su array di int.
Vincoli: portabile, nessuna dipendenza esterna, ogni funzione valida v/out/n.
Formato: sezioni numerate.

-------------------------------------------
PROMPT B - Codice
-------------------------------------------

Genera codice completo C99 per stats.h, stats.c, main.c.
Compilazione con gcc: -std=c99 -Wall -Wextra -Wpedantic -O0 -g.
Regole: codici errore coerenti, out scritto solo se OK.
Varianza popolazione: (1/n) * somma( (xi - mean)^2 ).
In main.c: esegui casi di prova e stampa risultati in modo leggibile (senza scanf).

-------------------------------------------
PROMPT C - Piano Test
-------------------------------------------

Genera un piano di test per stats (min, max, sum_ll, mean, variance_population).
Includi: casi normali, negativi, n==1, input invalidi (NULL, n<=0), valori
grandi per sum_ll.
Per ogni test: input, output atteso, motivazione.


========================================
SEZIONE 2: PIANO DI TEST
========================================

+--------+---------------------------+--------------------------------+----------------------------------------+
| Test # | Input                     | Output Atteso                  | Motivazione                            |
+--------+---------------------------+--------------------------------+----------------------------------------+
| 1      | v={1,2,3,4}, n=4          | min=1, max=4, sum=10,          | Caso normale con valori positivi       |
|        |                           | mean=2.5, var_pop=1.25         | per testare tutte le funzioni          |
+--------+---------------------------+--------------------------------+----------------------------------------+
| 2      | v={-5,-1,-3}, n=3         | min=-5, max=-1, sum=-9,        | Caso con valori negativi per           |
|        |                           | mean=-3.0                      | verificare correttezza con numeri < 0  |
+--------+---------------------------+--------------------------------+----------------------------------------+
| 3      | v={7}, n=1                | mean=7.0, var_pop=0.0          | Caso limite: array singolo             |
|        |                           |                                | (varianza deve essere 0)               |
+--------+---------------------------+--------------------------------+----------------------------------------+
| 4      | v=NULL, n=5               | rc != 0 (errore)               | Test validazione: puntatore NULL       |
+--------+---------------------------+--------------------------------+----------------------------------------+
| 5      | v={1,2,3}, n=3,           | rc != 0 (errore)               | Test validazione: output NULL          |
|        | out=NULL                  |                                |                                        |
+--------+---------------------------+--------------------------------+----------------------------------------+
| 6      | v={1,2,3}, n=0            | rc != 0 (errore)               | Test validazione: n<=0                 |
+--------+---------------------------+--------------------------------+----------------------------------------+
| 7      | v={1000000000,            | sum=3000000000                 | Test overflow: verifica che long long  |
|        | 1000000000,               | (con long long)                | prevenga overflow (int sarebbe         |
|        | 1000000000}, n=3          |                                | insufficiente: 3*10^9 > 2^31-1)        |
+--------+---------------------------+--------------------------------+----------------------------------------+


========================================
SEZIONE 3: RISULTATI TEST MANUALI
========================================

TEST 1: v={1,2,3,4}
-------------------
Atteso:  min=1, max=4, sum=10, mean=2.5, var_pop=1.25
Ottenuto: min=1, max=4, sum=10, mean=2.5, var_pop=1.25
Risultato: PASS ✓

TEST 2: v={-5,-1,-3}
--------------------
Atteso:  min=-5, max=-1, sum=-9, mean=-3.0
Ottenuto: min=-5, max=-1, sum=-9, mean=-3.0
Risultato: PASS ✓

TEST 3: v={7}
-------------
Atteso:  mean=7.0, var_pop=0.0
Ottenuto: mean=7.0, var_pop=0.0
Risultato: PASS ✓

TEST 4: Errore v=NULL
---------------------
Atteso:  rc != 0
Ottenuto: rc=-1
Risultato: PASS ✓

TEST 5: Errore out=NULL
-----------------------
Atteso:  rc != 0
Ottenuto: rc=-1
Risultato: PASS ✓

TEST 6: Errore n<=0
-------------------
Atteso:  rc != 0
Ottenuto: rc=-1
Risultato: PASS ✓

TEST 7: Somma grande
--------------------
Atteso:  sum=3000000000
Ottenuto: sum=3000000000
Risultato: PASS ✓


========================================
SEZIONE 4: IMPLEMENTAZIONE
========================================

Struttura dei file:
-------------------
- stats.h: Header con prototipi, documentazione pre/post-condizioni, note su complessità
- stats.c: Implementazione delle 5 funzioni con validazione input
- main.c: Test driver con 7 casi di test

Convenzioni adottate:
---------------------
- Codice errore: -1 per tutti gli errori (NULL pointer, n<=0)
- Ritorno: 0 se operazione completata con successo
- Validazione: controllo di v, out, n all'inizio di ogni funzione
- Output: scritto solo se validazione passa
- Overflow: stats_sum_ll usa long long per prevenire overflow
- Precisione: mean e variance usano double per precisione decimale

Algoritmi:
----------
1. stats_min/max: scan lineare O(n)
2. stats_sum_ll: accumulo in long long O(n)
3. stats_mean: somma + divisione O(n)
4. stats_variance_population: due passate O(n)
   - Prima passata: calcola media
   - Seconda passata: somma quadrati degli scarti
   - Formula: variance = Σ(xi - mean)² / n


========================================
SEZIONE 5: COMPILAZIONE ED ESECUZIONE
========================================

Comando di compilazione:
------------------------
gcc -std=c99 -Wall -Wextra -Wpedantic -O0 -g main.c stats.c -o app -lm

Parametri:
- -std=c99: Standard C99
- -Wall -Wextra -Wpedantic: Warning estesi
- -O0: Nessuna ottimizzazione (facilita debug)
- -g: Simboli di debug per gdb
- -lm: Link libreria matematica (opzionale, non usata ma sicura)

Esecuzione:
-----------
./app


========================================
SEZIONE 6: DEBUG CON GDB
========================================

Setup debug:
------------
gdb ./app

Comandi GDB utilizzabili per debug:
-----------------------------------

1. Avvio e breakpoint:
   (gdb) break main
   (gdb) break stats_variance_population
   (gdb) run

2. Navigazione:
   (gdb) next          # passo successivo (senza entrare)
   (gdb) step          # entra nella funzione
   (gdb) continue      # continua fino al prossimo breakpoint

3. Ispezione variabili:
   (gdb) print n
   (gdb) print v[0]
   (gdb) print v[1]
   (gdb) print mean
   (gdb) print var_pop
   (gdb) print sum_squared_deviations

4. Visualizzazione array:
   (gdb) print *v@4    # stampa primi 4 elementi dell'array

5. Stack trace:
   (gdb) backtrace     # visualizza lo stack delle chiamate

6. Uscita:
   (gdb) quit


Scenario debug tipico:
---------------------
Se il test della varianza fallisce:

1. break stats_variance_population
2. run
3. next (fino alla chiamata stats_mean)
4. step (entra in stats_mean)
5. print mean (verifica che la media sia corretta)
6. next (torna a variance_population)
7. next (attraversa il ciclo)
8. print i (indice corrente)
9. print deviation (scarto corrente)
10. print sum_squared_deviations (accumulo)
11. continue


========================================
SEZIONE 7: BUG TROVATI E RISOLTI
========================================

In questa implementazione non sono stati trovati bug perché:

1. Validazione input rigorosa all'inizio di ogni funzione
2. Uso di long long per prevenire overflow in stats_sum_ll
3. Uso di double per precisione in mean e variance
4. Formula corretta per varianza popolazione: divisore n (non n-1)
5. Output scritto solo dopo validazione successo
6. Test con valori negativi, singoli, grandi confermano correttezza


========================================
SEZIONE 8: NOTE AGGIUNTIVE
========================================

Precisione e overflow:
----------------------
- int range: -2,147,483,648 to 2,147,483,647
- long long range: -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807
- Il test 7 dimostra che 3×10⁹ richiederebbe overflow su int
- long long è sufficiente per somme di interi anche molto grandi

Varianza popolazione vs campionaria:
------------------------------------
- Popolazione: divisore n (implementata)
- Campionaria: divisore n-1 (non implementata, vedi estensione)
- La varianza campionaria è usata quando i dati sono un campione di una popolazione più grande

Estensioni possibili:
---------------------
1. stats_stddev_population: √variance usando sqrt() da <math.h>
2. stats_variance_sample: varianza campionaria con divisore (n-1)
3. Gestione robusta: non scrivere su out in caso di errore (già implementato)


========================================
FINE REPORT
========================================
